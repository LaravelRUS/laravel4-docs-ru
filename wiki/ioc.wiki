== Обратное управление (IoC) ==
{{Meta автор=из официальной документации, переводчик=Proger_XP, id переводчика=2, обновление=2.09.2013}}
{{Meta оригинал=doc4:ioc}}

{{TOC}}

== Введение ==
Класс-контейнер обратного управления **(?IoC Inversion of Control?)** Laravel - мощное средство для управления зависимостями классов. Внедрение зависимостей - это способ исключения вшитых (//hardcoded//) взаимосвязей классов. Вместо этого зависимости определяются во время выполнения, что даёт бо(')льшую гибкость благодаря тому, что они могут быть легко изменены.

Понимание IoC-контейнера Laravel необходимо для построения больших и мощных приложений, так же как и для внесения изменений в код ядра самого фреймворка.

== Основы использования ==
Есть два способа, которыми IoC-контейнер разрешает зависимости: через функцию-замыкание и через ((#автоматическое)) определение. Для начала мы исследуем замыкания. Первым делом некий "тип" должен быть помещён в контейнер.

**Помещение типа в контейнер:**
%%
  App::bind('foo', function ($app) {
    return new FooBar;
  });
%%

**Извлечение типа из контейнера:**
%%
  $value = App::make('foo');
%%

При вызове метода %%App::make()%% вызывается соответствующее замыкание и возвращается результат её вызова.

Иногда вам может понадобиться поместить в контейнер тип, котоый должно быть извлечён (создан) только один раз, и чтобы все последующие вызовы возвращали бы тот же объект.

**Помещение "разделяемого" типа в контейнер:**
%%
  App::singleton('foo', function () {
    return new FooBar;
  });
%%

.(tl_note)
**Singleton** - шаблон проектирования ((ВП:Одиночка (шаблон проектирования)==Одиночка)) - //прим. пер.//

Вы также можете поместить уже созданный экземпляр объекта в контейнер, используя метод %%instance()%%.

**Помещение готового экземпляра в контейнер:**
%%
  $foo = new Foo;

  App::instance('foo', $foo);
%%

== Автоматическое определение ==
Контейнер IoC достаточно мощен, чтобы во многих случаях определять классы автоматически, без дополнительной настройки.

**Автоопределение класса:**
%%
  class FooBar {

    public function __construct(Baz $baz)
    {
      $this->baz = $baz;
    }

  }

  $fooBar = App::make('FooBar');
%%

Обратите внимание, что даже без явного помещения класса %%FooBar%% в контейнер он всё равно был определён и зависимость %%Baz%% была автоматически внедрена в него.

Если тип не был найден в контейнере, IoC будет использовать возможности //((phpdoc:book.reflection рефлексии))// PHP для изучения класса и чтения подсказок типов (//type hints//) в его конструкторе. С помощью этой информации контейнер сам создаёт экземпляр класса.

Однако в некоторых случаях класс может принимать экземпляр интерфейса, а не сам объект. В этом случае нужно использовать метод %%App::bind()%% для извещения контейнра о том, какая именно зависимость должна быть внедрена.

**Связывание интерфейса и реализации:**
%%
  App::bind('UserRepositoryInterface', 'DbUserRepository');
%%

Теперь посмотрим на следующий ((controllers контроллер)):
%%
  class UserController extends BaseController {

    public function __construct(UserRepositoryInterface $users)
    {
      $this->users = $users;
    }

  }
%%

Благодаря тому, что мы связали %%UserRepositoryInterface%% с "настоящим" классом, %%DbUserRepository%%, он будет автоматически встроен в контроллер при его создании.

== Практическое использование ==
Laravel предоставляет несколько возможностей для использования контейнера IoC для повышения гибкости и стабильности вашего приложения. Основной пример - зависимости при использовании ((controllers контроллеров)). Все контроллеры извлекаются из IoC, что позволяет вам использовать зависимости на основе подсказок типов в их конструкторах - ведь они будут определены автоматически.

**Подсказки типов для указания зависимостей контроллера:**
%%
  class OrderController extends BaseController {

    // OrderRepository - подсказка типа - имя класса передаваемого аргумента-объекта.
    public function __construct(OrderRepository $orders)
    {
        $this->orders = $orders;
    }

    public function getIndex()
    {
        $all = $this->orders->all();

        return View::make('orders', compact('all'));
    }

  }
%%

В этом примере класс %%OrderRepository%% автоматически встроится в контроллер. Это значит, что при использовании ((testing юнит-тестов)) класс-заглушка для %%OrderRepository%% может быть добавлен в контейнер, таким образом легко имитируя взаимодействие с БД.

((routing#фильтры_маршрутов Фильтры)), ((responses#составители)) и ((events#классы-обработчики)) могут также извлекаться из IoC. При регистрации этих объектов просто передайте имя класса, который должен быть использован.

**Другие примеры использования IoC:**
%%
  Route::filter('foo', 'FooFilter');

  View::composer('foo', 'FooComposer');

  Event::listen('foo', 'FooHandler')
%%

== Поставщики услуг ==
Поставщики услуг (//service providers//) - отличный способ группировки схожих регистраций в IoC в одном месте. Их можно рассматривать как начальный запуск компонентов вашего приложения. Внутри поставщика услуг вы можете зарегистрировать драйвер авторизации, классы-хранилища вашего приложения или даже собственную команду ((artisan Artisan)).

На самом деле бо(')льшая часть компонентов Laravel включает поставщиков услуг. Все зарегистрированные поставщики в вашем приложении указаны в массиве **providers** файла настроек %%(t)app/config/app.php%%.

Для создания нового поставщика просто наследуйте класс %%Illuminate\Support\ServiceProvider%% и определите метод %%register()%%.

**Создание поставщика услуг:**
%%
  use Illuminate\Support\ServiceProvider;

  class FooServiceProvider extends ServiceProvider {

    public function register()
    {
      $this->app->bind('foo', function () {
        return new Foo;
      });
    }

  }
%%

Заметьте, что внутри метода %%register()%% IoC-контейнер приложения доступен в свойстве %%$this->app%%. Как только вы создали поставщика и готовы зарегистрировать его в своём приложении просто добавьте его в массив **providers** файла настроек %%(t)app.php%%.

Кроме этого, вы можете зарегистрировать его "на лету", используя метод %%App::register()%%.

**Регистрация поставщика услуг во время выполнения:**
%%
  App::register('FooServiceProvider');
%%

== События контейнера ==
Контейнер IoC возбуждает событие каждый раз при извлечении объекта. Вы можете отслеживать его с помощью метода %%resolving()%%.

**Регистрация обработчика события:**
%%
  App::resolving(function ($object) {
    //
  });
%%

Созданный объект передаётся в функцию в виде первого параметра.